unit DnTlsChannel;
interface
uses
  Classes, SysUtils, AnsiStrings,
  DnConst, DnRtl, DnTcpChannel, DnDataQueue, DnTcpReactor,
  OpenSSLImport, OpenSSLUtils, WS2;

const
  TlsDecodedBufferSize = 16384;
  TlsIncomingBufferSize = 16384;

type
  EDnSslException = class(EDnException)
  public
    constructor Create(ErrorCode: Integer);
  end;

  TDnTlsChannel = class(TDnTcpChannel)
  protected
    // OpenSSL's BIO buffers
    FInputBio, FOutputBio: PBIO;

    // OpenSSL's SSL session context
    FSSL: Pointer;

    // Incoming application data
    FIncomingAppData: TDnDataQueue;

    // Outgoing application data
    FOutgoingAppData: TDnDataQueue;

    // Incoming network data
    FIncoming: TDnDataQueue;

    // Data to send to network extracted from OutputBio
    FOutgoing: TDnDataQueue;

    // Writing now
    FWriting: Boolean;

    FHandshakeCompleted: Boolean;

    procedure InitSsl(SslCtx: Pointer);
    function GetConnected: Boolean;

  public
    constructor CreateClient(Reactor: TDnTcpReactor; const RemoteIp: AnsiString; RemotePort: Integer; SslCtx: Pointer);
    constructor CreateServer(Reactor: TDnTcpReactor; Socket: TSocket; Addr: TSockAddrIn; SslCtx: Pointer);

    destructor Destroy; override;

    // Processes via OpenSSL received data. Returns length of available application data.
    function HandleReceived(Buffer: PByte; Size: Integer): Integer;

    // Checks if there is data generated by SSL to send and moves this data to OutgoingData
    procedure CheckDataToSend;

    // Prepares to handshake as client
    procedure ConnectedAsClient;

    // Prepares to handshake as server
    procedure ConnectedAsServer;

    // Marks if data are sending now on channel
    property Writing: Boolean read FWriting write FWriting;

    // Returns if handshake was ok
    property Connected: Boolean read GetConnected;

    // Pointer to OpenSSL context
    property SSL: Pointer read FSSL write FSSL;

    // OpenSSL input buffer
    property InputBio: PBIO read FInputBio write FOutputBio;

    // OpenSSL output buffer
    property OutputBio: PBIO read FOutputBio write FOutputBio;

    // Buffer for outgoing application data
    property OutgoingAppData: TDnDataQueue read FOutgoingAppData;

    // Buffer for incoming application data
    property IncomingAppData: TDnDataQueue read FIncomingAppData;

    // Data prepared to send to network
    property OutgoingData: TDnDataQueue read FOutgoing;

    // Data received from network
    property IncomingData: TDnDataQueue read FIncoming;
  end;

implementation

constructor EDnSslException.Create(ErrorCode: Integer);
var Buf: AnsiString;
begin
  inherited Create(ErrSsl, ErrorCode);

  SetLength(Buf, 512);
  OpenSSLImport.ERR_error_string(ErrorCode, @Buf[1]);
  SetLength(Buf, AnsiStrings.StrLen(@Buf[1]));
  FErrorMessage := Buf;
end;

constructor TDnTlsChannel.CreateClient(Reactor: TDnTcpReactor; const RemoteIp: AnsiString; RemotePort: Integer; SslCtx: Pointer);
begin
  inherited CreateEmpty(Reactor, RemoteIp, RemotePort);

  InitSsl(SslCtx);
end;

constructor TDnTlsChannel.CreateServer(Reactor: TDnTcpReactor; Socket: TSocket; Addr: TSockAddrIn; SslCtx: Pointer);
begin
  inherited Create(Reactor, Socket, Addr);

  InitSsl(SslCtx);
end;

procedure TDnTlsChannel.InitSsl(SslCtx: Pointer);
begin
  FHandshakeCompleted := False;
  FWriting := False;
  FIncomingAppData := TDnDataQueue.Create(TlsDecodedBufferSize, TlsDecodedBufferSize);
  FOutgoingAppData := TDnDataQueue.Create(TlsDecodedBufferSize, TlsDecodedBufferSize);
  FIncoming := TDnDataQueue.Create(TlsIncomingBufferSize, TlsIncomingBufferSize);
  FOutgoing := TDnDataQueue.Create(TlsIncomingBufferSize, TlsIncomingBufferSize);

  FSSL := OpenSSLImport.SSL_new(SslCtx);
  if not Assigned(FSSL) then
    raise EDnSslException.Create(OpenSSLImport.ERR_get_error());

  FInputBio := OpenSSLImport.BIO_new(OpenSSLImport.BIO_s_mem);
  FOutputBio := OpenSSLImport.BIO_new(OpenSSLImport.BIO_s_mem);
  OpenSSLImport.SSL_set_bio(FSSL, FInputBio, FOutputBio);
end;

function TDnTlsChannel.GetConnected;
var S: Integer;
begin
  if FHandshakeCompleted then
    Result := True
  else
  begin
    S := OpenSSLImport.SSL_state(FSSL);
    FHandshakeCompleted := (S and $03) <> 0;
    Result := FHandshakeCompleted;
  end;
end;

destructor TDnTlsChannel.Destroy;
begin
  // FInputBio and FOutputBio are linked into FSSL context - it owns buffers so no delete them
  FInputBio := Nil;
  FOutputBio := Nil;

  if Assigned(FSSL) then
  begin
    OpenSSLImport.SSL_free(FSSL);
    FSSL := Nil;
  end;

  FreeAndNil(FOutgoing);
  FreeAndNil(FIncoming);
  FreeAndNil(FIncomingAppData);
  FreeAndNil(FOutgoingAppData);

  inherited Destroy;
end;

procedure TDnTlsChannel.ConnectedAsClient;
var ResCode: Integer;
begin
  ResCode := OpenSSLImport.SSL_connect(FSSL);
end;

procedure TDnTlsChannel.ConnectedAsServer;
var ResCode: Integer;
begin
  ResCode := OpenSSLImport.SSL_accept(FSSL);
end;

function TDnTlsChannel.HandleReceived(Buffer: PByte; Size: Integer): Integer;
var
    ResCode: Integer;
begin
  // Send received data to OpenSSL associated buffer
  if OpenSSLImport.BIO_write(FInputBio, Buffer, Size) < 1 then
    raise EDnSslException.Create(OpenSSLImport.ERR_get_error());

  // See how much was received application data
  repeat
    // Ensure there is enough space in FDecoded buffer
    FIncomingAppData.EnsureCapacity(FIncomingAppData.Size + TlsDecodedBufferSize);

    // Decode data
    ResCode := OpenSSLImport.SSL_read(FSSL, FIncomingAppData.Memory + FIncomingAppData.Size, TlsDecodedBufferSize);

    if ResCode > 0 then
      FIncomingAppData.Size := FIncomingAppData.Size + ResCode;

  until ResCode <= 0;

  Result := OpenSSLImport.SSL_get_error(FSSL, ResCode);
end;

procedure TDnTlsChannel.CheckDataToSend;
var ResCode: Integer;
begin
  // See if there is outgoing application data
  if FOutgoingAppData.Size > 0 then
  begin
    repeat
      ResCode := OpenSSLImport.SSL_write(FSSL, FOutgoingAppData.Memory, FOutgoingAppData.Size);
      if ResCode > 0 then
        FOutgoingAppData.Delete(ResCode);
    until ResCode <= 0;
  end;

  repeat
    // Ensure outgoing encrypted data buffer has enough space
    FOutgoing.EnsureCapacity(FOutgoing.Size + TlsIncomingBufferSize);

    // Copy to buffer
    ResCode := OpenSSLImport.BIO_read(FOutputBio, FOutgoing.Memory + FOutgoing.Size, TlsIncomingBufferSize);

    // Increment size of buffer
    if ResCode > 0 then
      FOutgoing.Size := FOutgoing.Size + ResCode;
  until ResCode <= 0;
end;



end.
